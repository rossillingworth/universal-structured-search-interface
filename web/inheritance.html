<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="js/lodash.compat.js"></script>
</head>
<body>

<h1>Testing JS inheritance POC</h1>

<script src="js/ExceptionExtensions.js"></script>

<script>

    // TODO - share prototypes
    // TODO - NEED an extend function that only takes if hasOwnProperty==true


    // JS
    // Constructor.prototype -> properties & methods added to instances of Object created with new Constructor



    var CLASS = {
        // collection of constructor functions
        constructors:{},
        overrides:{},
        mixins:{},
        // create object
        // create extends hierarchy - heirarchy of prototypes
        // ?? create every time?
        // ?? reuse previous prototypes
        register:function(config){

            // hidden config, allows override on underlying prototype
            var underlyingPrototype = config.underlyingPrototype || Object.prototype;
            var allowParentConstructor = !!config.allowParentConstructor;

            // get base class constructor
            var baseName = config.extends;
            var baseConstructor = CLASS.constructors[baseName];
            EXCEPTION.when(!!baseName && !(!!baseConstructor),"No base instance of %s",baseName);

            // create constructor
            function INHERITANCE(){
                console.log("Inheritance for " + config.extends);
            };
            function CONSTRUCTOR(){
                console.log("Constructor for " + config.extends);
                // TODO - should this be possible to override in the config
                // !!config.constructor && config.constructor.apply(this,[].slice.apply(arguments));
                // allowParentConstructor && baseConstructor.prototype.constructor.apply(this,[].slice.apply(arguments));
                // TODO - should we call init from here?
                // this.init.apply(this,[].slice.apply(arguments));
            };

            // assign (base prototype or Object.prototype) to our intermediary prototype
            // inherit baseConstructor prototype without creating an instance on baseConstructor
            // this is also done to avoid polluting the baseConstructor.prototype
            INHERITANCE.prototype = baseConstructor ? baseConstructor.prototype : underlyingPrototype;
            CONSTRUCTOR.prototype = new INHERITANCE();
            CONSTRUCTOR.prototype.constructor = CONSTRUCTOR;
            // TODO - assign _super? - already available with prototype
            // TODO - assign _superConstructor?

            // decorate constructor with specified mixins
            // TODO - should construtors be allowed in mixins?
            if(config.extendWith && config.extendWith.length > 0){
                for(var i in config.extendWith){
                    var extensionName = config.extendWith[i];
                    var extensionConstructor = CLASS.constructors[extensionName];
                    EXCEPTION.when(!!extensionConstructor,"No Mixin instance of %s",extensionName);
                    _.extend(CONSTRUCTOR.prototype,new extensionConstructor());
                }
            }

            // implement overrides
            var overrides = CLASS.overrides[config.name];
            if(!!overrides){
                for(var i in overrides){
                    _.extend(CONSTRUCTOR.prototype,overrides[i]);
                }
            }

            // now add all other config properties
            _.extend(CONSTRUCTOR.prototype,config);
            CLASS.constructors[config.name] = CONSTRUCTOR;
        },

        new:function(typeName,jsonConfig){
            var o = new CLASS.constructors[typeName]();
            !!o.init &&  o.init(jsonConfig);
            return o;
        },
        /**
         * Used to extend/modify functionality of any component
         * without touching the source code.
         * ie: temporary
         *
         * @param name
         * @param jsonConfig
         */
        override:function(name,jsonConfig){
            // ensure named override container exists
            !CLASS.overrides[name] && (CLASS.overrides[name] = []);
            CLASS.overrides[name].push(jsonConfig);
        }
    };




    //###################################################

    CLASS.override("base",{
        myVar:999,
        getVar:function(){
            console.log("getting " + this.myVar);
            return this.myVar;
        }
        ,setVar:function(val){
            this.myVar = val;
        }
    });

    // TODO - put config into sub object is JSON
    CLASS.register({
        name:"base"
        ,extends:""
        ,extendWith:[]
        ,config:{}
        ,myVarXXX:0
        ,init:function(val){
            console.log("init base");
            this.myVarXXX = val;
        }
        ,func1:function (){
            console.log("func1");
        }
    });

    CLASS.register({
        name:"extend1"
        ,extends:"base"
        ,init:function(){
            console.log("init extend1");
        }
        ,func3:function(){
            console.log("func3");
        }
    });

    CLASS.register({
        name:"extend2"
        ,extends:"base"
        ,extendWith:[]
        ,init:function(){
            console.log("__proto__",this.__proto__);
            debugger;
            this.__proto__.__proto__.init(777);
            var p = this.__proto__;
            while(!p.name=="base"){
                p = p.__proto__;
            }

            console.log("init extend2");
            console.log(this.myVarXXX);
        }
    });

    var b = CLASS.new("base",{});
    console.log(b.getVar());
    b.setVar(666);

    var e = CLASS.new("extend1",{});
    console.log(e.getVar())

    console.log(b.getVar());

    var e2 = CLASS.new("extend2",{});

    // TODO - PROTOTYPE is SHARED

</script>

</body>
</html>